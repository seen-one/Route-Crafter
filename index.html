<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Route Crafter</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" integrity="sha512-Zcn6bjR/8RZbLEpLIeOwNtzREBAJnUKESxces60Mpoj+2okopSAcSUIUOseddDm0cxnGQzxIR7vJgsLZbdLE3w==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js" integrity="sha512-BwHfrr4c9kmRkLw6iXFdzcdWV/PGkVgiIyIWLLlTSXzWQzxuSg4DiQUCpauz/EWjgk5TYQqX/kvn9pG1NpYfqg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://unpkg.com/osmtogeojson@3.0.0-beta.5/osmtogeojson.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Turf.js/6.5.0/turf.min.js" integrity="sha512-Q7HOppxoH0L2M7hreVoFCtUZimR2YaY0fBewIYzkCgmNtgOOZ5IgMNYxHgfps0qrO1ef5m7L1FeHrhXlq1I9HA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-gpx/2.2.0/gpx.min.js" integrity="sha512-i9cfK7mcbURqnNfNFYqNhB4/Ae5xAgrrGFPgRnVB5Ws6Xac3BbYqFwtMbyf3QZW8Nq+F7gcWGsM0HUyoA/RVIw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://unpkg.com/leaflet.vectorgrid@1.3.0/dist/Leaflet.VectorGrid.js"></script>
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            height: 100%;
        }

        #map {
            height: 100%;
            /* Make the map fill the entire viewport */
        }

        #controls {
            height: 15vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #f4f4f4;
            border-top: 1px solid #ddd;
        }

        button,
        input,
        select,
        label,
        p {
            margin: 5px 5px;
            padding: 10px 10px;
            font-size: 15px;
            cursor: pointer;
        }

        /* Ensure statistics use the same font size as labels on desktop */
        #routeLength {
            font-size: 15px;
        }

        /* Hide statistics when empty */
        #routeLength:empty {
            display: none;
        }

        button {
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
        }

        button:hover {
            background-color: #0056b3;
        }

        /* Add this to your CSS section */
        .button-loading {
            position: relative;
            pointer-events: none;
            /* Disable clicking while loading */
            opacity: 0.7;
        }

        .button-loading .spinner {
            position: absolute;
            top: 50%;
            right: 15px;
            width: 16px;
            height: 16px;
            margin-top: -8px;
            /* Half of spinner height to center vertically */
            border: 2px solid transparent;
            border-top-color: white;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }

        /* Styles for the filter control from combined.html */
        .leaflet-control-filters {
            background: #f0f0f0;
            padding: 8px 12px;
            font-size: 14px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
            border-radius: 5px;
            max-width: 300px;
            display: none; /* Hidden by default */
        }

        .leaflet-control-filters label {
            display: block;
            margin-bottom: 6px;
        }

        .leaflet-control-filters input[type="date"],
        .leaflet-control-filters input[type="text"] {
            width: 100%;
            box-sizing: border-box;
        }

        .leaflet-control-filters button,
        #toggleFilterBtn {
            margin-top: 6px;
            width: 100%;
            cursor: pointer;
        }

        .image-type-btn {
            display: inline-block;
            margin: 0;
            padding: 4px 8px;
            font-size: 12px;
            border: 1px solid #ccc;
            background-color: #f9f9f9;
            color: #333;
            cursor: pointer;
            border-radius: 3px;
            flex: 1;
            min-width: 0;
            box-sizing: border-box;
        }

        .image-type-btn:hover {
            background-color: #e9e9e9;
            color: #333;
        }

        .image-type-btn.active {
            background-color: #007bff;
            color: white;
            border-color: #007bff;
        }

        /* Style for the zoom tip */
        .leaflet-control-filters .zoom-tip {
            font-size: 12px;
            color: #555;
			margin: 12px;
            font-style: italic;
        }
		
        /* Context Menu Styles */
        .context-menu {
            position: absolute;
            background: white;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
            min-width: 200px;
            display: none;
        }

        .context-menu-item {
            margin: 5px 5px;
            padding: 10px 10px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
            font-size: 15px;
            font-family: Arial, sans-serif;
            color: #333;
        }

        .context-menu-item:last-child {
            border-bottom: none;
        }

        .context-menu-item:hover {
            background-color: #f5f5f5;
        }

        .context-menu-item:active {
            background-color: #e0e0e0;
        }

        /* Media Player Controls Styles */
        .media-controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 10px 15px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            display: none;
            z-index: 1000;
            min-width: 300px;
            font-family: "Helvetica Neue", Arial, Helvetica, sans-serif;
            font-size: 12px;
        }

        .media-controls.visible {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .media-controls-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .media-btn {
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 14px;
            min-width: 40px;
        }

        .media-btn:hover {
            background: #0056b3;
        }

        .media-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .media-btn.active {
            background: #28a745;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .speed-btn {
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 4px 8px;
            cursor: pointer;
            font-size: 12px;
        }

        .speed-btn:hover {
            background: #545b62;
        }

        .speed-btn.active {
            background: #007bff;
        }

        .progress-container {
            width: 100%;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .progress-bar {
            flex: 1;
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            cursor: pointer;
            position: relative;
        }

        .progress-bar:hover {
            height: 10px;
        }

        .progress-fill {
            height: 100%;
            background: #007bff;
            width: 0%;
            transition: width 0.1s ease;
        }

        .progress-bar.dragging {
            cursor: grabbing;
        }

        .progress-text {
            font-size: 12px;
            color: #666;
            min-width: 80px;
            text-align: center;
        }

        /* Mobile controls styles */
        .leaflet-bar {
            max-width: 90vw;
            max-height: 70vh;
            overflow-y: auto;
        }

        .leaflet-bar div {
            padding: 5px;
            background: white;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }

        /* Combined Media query for smaller screens (portrait and landscape mobile) */
        @media (max-width: 600px), /* For portrait phones and small tablets */
               (max-height: 450px) and (orientation: landscape) { /* For landscape phones where height is constrained */
            .leaflet-control-filters {
                max-width: 95%; /* Adjust max-width to a percentage of the screen */
                max-height: 70vh; /* Limit height to prevent overflow on very short screens */
                overflow-y: auto; /* Allow scrolling if content overflows max-height */
                padding: 5px; /* Reduce padding */
                font-size: 12px; /* Smaller font size */
                top: 5px !important; /* Adjust top position for closer to edge */
                right: 5px !important; /* Adjust right position for closer to edge */
            }

            .leaflet-control-filters label {
                margin-bottom: 3px; /* Further reduce margin between labels */
                font-size: 11px; /* Even smaller label font size */
            }

            .leaflet-control-filters input[type="date"],
            .leaflet-control-filters input[type="text"] {
                padding: 3px; /* Further reduce input padding */
                font-size: 11px; /* Even smaller input font size */
            }

            .leaflet-control-filters button {
                padding: 4px 6px; /* Further reduce button padding */
                font-size: 11px; /* Even smaller button font size */
            }

            .leaflet-control-filters .zoom-tip {
                font-size: 10px; /* Smaller tip font size */
            }

            /* Adjust the toggle button styles for better appearance on mobile */
            #toggleFilterBtn {
                padding: 5px 8px; /* Slightly larger padding for better touch target */
                font-size: 12px; /* Keep it readable */
                margin-top: 5px; /* Add margin to separate from other controls */
                margin-right: 5px; /* Keep it consistent with filter menu right margin */
                /* Do NOT set top/right !important here, let Leaflet handle stacking */
            }

             /* Ensure all controls in the top-right have some padding/margin to not stick to the corner */
             .leaflet-top.leaflet-right .leaflet-control {
                 margin-top: 5px;
                 margin-right: 5px;
             }

             /* Position the toggle filter button at the top of top-right controls */
             .leaflet-top.leaflet-right .leaflet-control:first-child {
                 margin-top: 5px;
                 margin-right: 5px;
             }

             /* Hide bottom controls when filter menu is open on mobile */
             .leaflet-bottom.hidden-on-mobile {
                 display: none !important;
             }

             /* Set max height of leaflet-right controls to 80% from top */
             .leaflet-top.leaflet-right {
                 max-height: 80vh;
                 overflow-y: auto;
             }

             /* Media controls mobile styles */
             .media-controls {
                 min-width: 280px;
                 padding: 8px 12px;
                 bottom: 10px;
             }

             .media-controls-row {
                 gap: 8px;
             }

             .media-btn {
                 padding: 6px 10px;
                 font-size: 12px;
                 min-width: 35px;
             }

             .speed-btn {
                 padding: 3px 6px;
                 font-size: 11px;
             }

             /* Hide leaflet-bottom when media controls are visible on mobile */
             .media-controls.visible ~ .leaflet-bottom,
             .media-controls.visible + * .leaflet-bottom {
                 display: none !important;
             }

             .progress-text {
                 font-size: 11px;
                 min-width: 70px;
             }

             /* Mobile controls styles */
             .leaflet-bar {
                 max-width: 95vw;
                 max-height: 60vh;
                 font-size: 12px;
             }

             .leaflet-bar div {
                 padding: 3px;
                 font-size: 12px;
             }

             .leaflet-bar input,
             .leaflet-bar select,
             .leaflet-bar button {
                 font-size: 12px;
                 padding: 6px 8px;
                 margin: 2px;
             }

        .leaflet-bar label {
            font-size: 11px;
            margin: 2px 0;
        }

        /* Ensure statistics use the same font size as labels */
        #routeLength {
            font-size: 11px;
            margin-left: 0;
            margin-right: 0;
        }

        /* Hide statistics when empty */
        #routeLength:empty {
            display: none;
        }

         }
    </style>
</head>

<body>
    <div id="map"></div>
    
    <!-- Context Menu -->
    <div id="contextMenu" class="context-menu">
        <div class="context-menu-item" data-service="openstreetmap">OpenStreetMap</div>
        <div class="context-menu-item" data-service="openstreetmap-query">Query Features</div>
        <div class="context-menu-item" data-service="nominatim">Nominatim</div>
        <div class="context-menu-item" data-service="mapillary">Mapillary</div>
        <div class="context-menu-item" data-service="panoramax">Panoramax</div>
        <div class="context-menu-item" data-service="kartaview">KartaView</div>
        <div class="context-menu-item" data-service="mapilio">Mapilio</div>
    </div>

    <!-- Media Player Controls -->
    <div id="mediaControls" class="media-controls">
        <div class="progress-container">
            <div class="progress-bar" id="progressBar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="progress-text" id="progressText">0.0 km / 0.0 km</div>
        </div>
        <div class="media-controls-row">
            <button class="media-btn" id="playFromBeginningBtn">⏮️</button>
            <button class="media-btn" id="playPauseBtn">▶️</button>
            <button class="media-btn" id="closeBtn">✕</button>
        </div>
        <div class="media-controls-row">
            <div class="speed-control">
                <span style="font-size: 12px; color: #666;">Speed:</span>
                <button class="speed-btn" data-speed="0.1">0.1x</button>
                <button class="speed-btn" data-speed="0.25">0.25x</button>
                <button class="speed-btn" data-speed="0.5">0.5x</button>
                <button class="speed-btn active" data-speed="1">1x</button>
                <button class="speed-btn" data-speed="2">2x</button>
            </div>
        </div>
    </div>
    <script>
        const highlightedPolygons = []; // To store highlighted polygons' Leaflet layers
        let previewLayer = null; // To hold the preview layer for the combined polygon
        let geoJsonLayer = null; // Layer to hold the fetched residential areas
        // Initialize the map with wraparound enabled
        const map = L.map('map', {
            worldCopyJump: true // Enable world wraparound
        });

        // Function to save map state to URL hash fragment (OpenStreetMap style)
        function saveMapStateToHash() {
            const center = map.getCenter();
            const zoom = map.getZoom();
            const hash = `#map=${zoom}/${center.lat.toFixed(6)}/${center.lng.toFixed(6)}`;
            window.location.hash = hash;
        }

        // Function to restore map state from URL hash fragment (OpenStreetMap style)
        function restoreMapStateFromHash() {
            const hash = window.location.hash.substring(1); // Remove the # symbol
            if (hash && hash.startsWith('map=')) {
                const mapPart = hash.substring(4); // Remove 'map=' prefix
                const parts = mapPart.split('/');
                
                if (parts.length === 3) {
                    const zoom = parseInt(parts[0]);
                    const lat = parseFloat(parts[1]);
                    const lng = parseFloat(parts[2]);
                    
                    if (!isNaN(lat) && !isNaN(lng) && !isNaN(zoom)) {
                        map.setView([lat, lng], zoom);
                        return true; // Successfully restored from hash
                    }
                }
            }
            return false; // No valid hash data found
        }

        // Initialize map with default view or restore from hash
        if (!restoreMapStateFromHash()) {
            map.setView([51.505, -0.09], 13); // Default view if no hash
        }

        // Define basemap layers
        var baseMaps = {
            "OpenStreetMap": L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 19,
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }),
            "CartoDB Positron": L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
                subdomains: 'abcd',
                maxZoom: 19
            }),
            "CartoDB Dark Matter": L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
                subdomains: 'abcd',
                maxZoom: 19
            }),
            "CartoDB Voyager": L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
                subdomains: 'abcd',
                maxZoom: 19
            }),
            "Esri World Imagery": L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                maxZoom: 19,
                attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
            }),
            "Esri World Street Map": L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}', {
                maxZoom: 19,
                attribution: 'Tiles &copy; Esri &mdash; Source: Esri, DeLorme, NAVTEQ, USGS, Intermap, iPC, NRCAN, Esri Japan, METI, Esri China (Hong Kong), Esri (Thailand), TomTom, 2012'
            }),
            "Esri World Topographic": L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}', {
                maxZoom: 19,
                attribution: 'Tiles &copy; Esri &mdash; Source: USGS, Esri, TANA, DeLorme, and NPS'
            }),
            "OpenTopoMap": L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
                maxZoom: 17,
                attribution: 'Map data: &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, <a href="http://viewfinderpanoramas.org">SRTM</a> | Map style: &copy; <a href="https://opentopomap.org">OpenTopoMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)'
            }),
            "CyclOSM": L.tileLayer('https://{s}.tile-cyclosm.openstreetmap.fr/cyclosm/{z}/{x}/{y}.png', {
                maxZoom: 19,
                attribution: '<a href="https://github.com/cyclosm/cyclosm-cartocss-style/releases" title="CyclOSM - Open Bicycle render">CyclOSM</a> | Map data: &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            })
        };

        // Add default OpenStreetMap tiles
        baseMaps["OpenStreetMap"].addTo(map);

        // Add event listeners to save map state when view changes
        let hashUpdateTimeout;
        function debouncedSaveMapState() {
            clearTimeout(hashUpdateTimeout);
            hashUpdateTimeout = setTimeout(saveMapStateToHash, 500); // Debounce to avoid too frequent updates
        }

        map.on('moveend', debouncedSaveMapState);
        map.on('zoomend', debouncedSaveMapState);

        // Context Menu functionality
        const contextMenu = document.getElementById('contextMenu');
        let contextMenuVisible = false;
        let lastClickLatLng = null;

        // Function to generate URLs for different mapping services
        function generateServiceUrl(service, lat, lng, zoom) {
            const latFixed = lat.toFixed(6);
            const lngFixed = lng.toFixed(6);
            const zoomFixed = zoom.toFixed(2);
            
            // Get current map center for services that need it
            const mapCenter = map.getCenter();
            const mapCenterLatFixed = mapCenter.lat.toFixed(6);
            const mapCenterLngFixed = mapCenter.lng.toFixed(6);
            
            switch(service) {
                case 'openstreetmap':
                    return `https://www.openstreetmap.org/#map=${Math.round(zoom)}/${latFixed}/${lngFixed}`;
                case 'openstreetmap-query':
                    return `https://www.openstreetmap.org/query?lat=${latFixed}&lon=${lngFixed}#map=${Math.round(zoom)}/${mapCenterLatFixed}/${mapCenterLngFixed}`;
                case 'nominatim':
                    return `https://nominatim.openstreetmap.org/ui/reverse.html?lat=${latFixed}&lon=${lngFixed}`;
                case 'mapillary':
                    return `https://www.mapillary.com/app/?lat=${latFixed}&lng=${lngFixed}&z=${zoomFixed}`;
                case 'panoramax':
                    return `https://api.panoramax.xyz/?focus=map&map=${zoomFixed}/${latFixed}/${lngFixed}&`;
                case 'kartaview':
                    return `https://kartaview.org/map/@${latFixed},${lngFixed},${Math.round(zoom)}z`;
                case 'mapilio':
                    return `https://www.mapilio.com/app?lat=${latFixed}&lng=${lngFixed}&zoom=${zoomFixed}`;
                default:
                    return '#';
            }
        }

        // Function to show context menu
        function showContextMenu(e) {
            e.preventDefault();
            e.stopPropagation();
            
            const latlng = e.latlng || e.target.getLatLng();
            lastClickLatLng = latlng;
            
            const mapContainer = map.getContainer();
            const rect = mapContainer.getBoundingClientRect();
            
            // Calculate position relative to the map container
            let x, y;
            if (e.originalEvent) {
                x = e.originalEvent.clientX - rect.left;
                y = e.originalEvent.clientY - rect.top;
            } else {
                // For touch events
                x = e.originalEvent.touches[0].clientX - rect.left;
                y = e.originalEvent.touches[0].clientY - rect.top;
            }
            
            // Position the context menu
            contextMenu.style.left = x + 'px';
            contextMenu.style.top = y + 'px';
            contextMenu.style.display = 'block';
            contextMenuVisible = true;
        }

        // Function to hide context menu
        function hideContextMenu() {
            contextMenu.style.display = 'none';
            contextMenuVisible = false;
        }

        // Add right-click event listener to map
        map.on('contextmenu', showContextMenu);

        // Alternative method: Add direct event listener to map container
        const mapContainer = map.getContainer();
        mapContainer.addEventListener('contextmenu', function(e) {
            e.preventDefault();
            const latlng = map.containerPointToLatLng([e.offsetX, e.offsetY]);
            const fakeEvent = {
                latlng: latlng,
                originalEvent: e,
                preventDefault: () => e.preventDefault(),
                stopPropagation: () => e.stopPropagation()
            };
            showContextMenu(fakeEvent);
        });

        // Add long-press event listener for touch devices
        let touchStartTime = 0;
        let touchTimer = null;
        
        map.on('touchstart', function(e) {
            touchStartTime = Date.now();
            touchTimer = setTimeout(() => {
                showContextMenu(e);
            }, 500); // 500ms long press
        });

        map.on('touchend', function(e) {
            if (touchTimer) {
                clearTimeout(touchTimer);
                touchTimer = null;
            }
        });

        map.on('touchmove', function(e) {
            if (touchTimer) {
                clearTimeout(touchTimer);
                touchTimer = null;
            }
        });

        // Hide context menu when clicking elsewhere
        map.on('click', hideContextMenu);
        map.on('zoomstart', hideContextMenu);
        map.on('movestart', hideContextMenu);

        // Add click event listeners to context menu items
        document.querySelectorAll('.context-menu-item').forEach(item => {
            item.addEventListener('click', function(e) {
                e.stopPropagation();
                if (lastClickLatLng) {
                    const service = this.getAttribute('data-service');
                    const zoom = map.getZoom();
                    const url = generateServiceUrl(service, lastClickLatLng.lat, lastClickLatLng.lng, zoom);
                    window.open(url, '_blank');
                }
                hideContextMenu();
            });
        });

        // Hide context menu when clicking outside
        document.addEventListener('click', function(e) {
            if (contextMenuVisible && !contextMenu.contains(e.target)) {
                hideContextMenu();
            }
        });


        // Custom controls container for Route Crafter features
        const controlsContainer = L.control({ position: 'bottomleft' });
        let controlsDiv = null; // Store reference to the controls div

        controlsContainer.onAdd = function () {
            const div = L.DomUtil.create('div', 'leaflet-bar');
            div.innerHTML = `
                <div id="mainControlsDiv" style="padding: 5px; background: white;">
                    <input type="text" id="searchBox" placeholder="Search Map" />
                    <button id="searchButton">Search</button>
                    <br>
                    <select id="searchRules">
                        <option value="landuse=residential|landuse=retail|landuse=commercial|landuse=industrial">Landuse: Residential/Retail/Commercial/Industrial</option>
                        <option value="admin_level=10">Admin Level 10</option>
                        <option value="admin_level=9">Admin Level 9</option>
                        <option value="admin_level=8">Admin Level 8</option>
                        <option value="admin_level=7">Admin Level 7</option>
                        <option value="boundary=neighborhood">Boundary: Neighborhood</option>
                        <option value="boundary=political">Boundary: Political</option>
                        <option value="boundary=place">Boundary: Place</option>
                        <option value="boundary=census">Boundary: Census</option>
                        <option value="place=suburb">Place: Suburb</option>
                        <option value="place=quarter">Place: Quarter</option>
                        <option value="place=postal_code">Place: Postal Code</option>
                        <option value="place=district">Place: District</option>
                        <option value="place=subdistrict">Place: Subdistrict</option>
                    </select>
                    <button id="fetchButton">Find Areas</button>
                    <br>
                    <button id="previewGPXButton">Generate Route</button>
                    <button id="playRouteButton">Play Route</button>
                    <button id="downloadButton">Download GPX File</button>
                    <button id="clearButton">Reset</button>
                    <br>
                    <label for="bufferSize">Add buffer to selected areas (in meters): </label>
                    <input type="number" id="bufferSize" min="1" max="100" value="1">
                    <p id="routeLength"></p>
                </div>
            `;
            L.DomEvent.disableClickPropagation(div); // Prevent map interactions when interacting with the controls
            
            // Store reference to the controls div
            controlsDiv = div.querySelector('#mainControlsDiv');
            
            return div;
        };

        controlsContainer.addTo(map);

        // Add the preview automatically when a polygon is clicked
        function fetchDataByRule() {
            const fetchButton = document.getElementById('fetchButton');
            // Add loading spinner
            fetchButton.classList.add('button-loading');
            fetchButton.innerHTML = 'Finding Areas <span class="spinner"></span>';
            const selectedRule = document.getElementById('searchRules').value;
            if (geoJsonLayer) {
                map.removeLayer(geoJsonLayer);
            }
            const bounds = map.getBounds();
            const bbox = `${bounds.getSouth()},${bounds.getWest()},${bounds.getNorth()},${bounds.getEast()}`;
            let overpassQuery;
            if (selectedRule === "landuse=residential|landuse=retail|landuse=commercial|landuse=industrial") {
                overpassQuery = `
                    [out:json][timeout:10];
                    (
                        nwr[landuse=residential](${bbox});
                        nwr[landuse=retail](${bbox});
                        nwr[landuse=commercial](${bbox});
                        nwr[landuse=industrial](${bbox});
                    );
                    (._;>;);
                    out body;
                `;
            } else {
                overpassQuery = `
                    [out:json][timeout:10];
                    (
                        relation[${selectedRule}](${bbox});
                    );
                    (._;>;);
                    out body;
                `;
            }
            const url = `https://overpass-api.de/api/interpreter?data=${encodeURIComponent(overpassQuery)}`;
            fetch(url).then(response => {
                // Check if the response is ok (status 200-299)
                if (!response.ok) {
                    // Handle different HTTP error status codes
                    let errorMessage = '';
                    switch (response.status) {
                        case 504:
                            errorMessage = 'Gateway Timeout (504): The server took too long to respond. Please try again or zoom into a smaller area.';
                            break;
                        case 502:
                            errorMessage = 'Bad Gateway (502): The server is temporarily unavailable. Please try again later.';
                            break;
                        case 503:
                            errorMessage = 'Service Unavailable (503): The server is temporarily overloaded. Please try again later.';
                            break;
                        case 429:
                            errorMessage = 'Too Many Requests (429): Rate limit exceeded. Please wait a moment before trying again.';
                            break;
                        case 400:
                            errorMessage = 'Bad Request (400): Invalid query parameters. Please try a different search.';
                            break;
                        default:
                            errorMessage = `Server Error (${response.status}): ${response.statusText}. Please try again.`;
                    }
                    throw new Error(errorMessage);
                }
                return response.json();
            }).then(data => {
                if (data.remark && data.remark.includes('Query timed out')) {
                    throw new Error('Too many results. Please zoom into a smaller area. (Overpass query timed out after 10 seconds)');
                }
                const geoJsonData = osmtogeojson(data);
                const filteredData = geoJsonData.features.filter(feature => {
                    return feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon';
                });
                if (filteredData.length === 0) {
                    alert('No results found. Please try another search rule.');
                } else {
                    const processedData = filteredData.map(feature => {
                        if (feature.geometry.type === 'MultiPolygon') {
                            const outerPolygon = feature.geometry.coordinates[0];
                            feature.geometry.coordinates = [outerPolygon];
                        }
                        const area = turf.area(feature);
                        return {
                            feature,
                            area
                        };
                    }).sort((a, b) => b.area - a.area);
                    geoJsonLayer = L.geoJSON({
                        type: "FeatureCollection",
                        features: processedData.map(item => item.feature)
                    }, {
                        style: {
                            color: 'blue',
                            weight: 2
                        },
                        onEachFeature: (feature, layer) => {
                            layer.on('click', () => {
                                if (previewLayer) {
                                    map.removeLayer(previewLayer);
                                    previewLayer = null;
                                }
                                const index = highlightedPolygons.indexOf(layer);
                                if (index > -1) {
                                    highlightedPolygons.splice(index, 1);
                                    layer.setStyle({
                                        color: 'blue',
                                        weight: 2
                                    });
                                } else {
                                    highlightedPolygons.push(layer);
                                    layer.setStyle({
                                        color: 'red',
                                        weight: 3
                                    });
                                }
                                previewCombinedPolygon();
                            });
                        }
                    }).addTo(map);
                }
            }).catch(err => {
                console.error('Error fetching data:', err);
                // Display the error message in an alert
                const errorMessage = err.message || 'An unexpected error occurred while fetching data. Please try again.';
                alert(`Error: ${errorMessage}`);
            }).finally(() => {
                // Remove loading spinner and reset button text
                fetchButton.classList.remove('button-loading');
                fetchButton.innerHTML = 'Find Areas';
            });
        }
        // Function to preview the combined polygon with selected buffer size
        function previewCombinedPolygon() {
            if (highlightedPolygons.length === 0) {
                // Handle the case when there are no selected polygons
                if (previewLayer) {
                    // If there's an existing preview, remove it
                    map.removeLayer(previewLayer);
                    previewLayer = null; // Reset preview layer
                }
                // Clear the route length display
                document.getElementById('routeLength').innerHTML = '';
                return; // Exit function if no polygons are selected
            }
            // Get the buffer size from the input, defaulting to 0 if it's blank or invalid
            let bufferSize = parseInt(document.getElementById('bufferSize').value, 10);
            // If bufferSize is NaN (i.e., input was empty or invalid), set it to 0
            if (isNaN(bufferSize)) {
                bufferSize = 0;
            }
            
            // Calculate area statistics for the selected polygons
            let areaStats = '';
            try {
                const bufferedPolygons = highlightedPolygons.map(layer => {
                    const geoJson = layer.toGeoJSON();
                    return turf.buffer(geoJson, bufferSize, {
                        units: 'meters'
                    });
                });
                const combinedPolygon = bufferedPolygons.reduce((combined, feature, index) => {
                    if (index === 0) return feature;
                    return turf.union(combined, feature);
                });
                
                const areaInSquareMeters = turf.area(combinedPolygon);
                const areaInSquareKm = areaInSquareMeters / 1000000; // Convert to km²
                const areaInSquareMi = areaInSquareMeters / 2589988.11; // Convert to sq mi
                
                // Create area statistics display
                const areaWarning = areaInSquareKm > 5 ? ' <span style="color: red; font-weight: bold;">⚠️ Large Area</span>' : '';
                areaStats = `<strong>Selected Area:</strong> ${areaInSquareKm.toFixed(2)} km² (${areaInSquareMi.toFixed(2)} sq mi)${areaWarning}<br>`;
                
                // Update the route length display with area information
                document.getElementById('routeLength').innerHTML = areaStats;
            } catch (err) {
                console.error('Error calculating area:', err);
                document.getElementById('routeLength').innerHTML = '<span style="color: red;">Error calculating area</span><br>';
            }
            
            // If the buffer size is 0, skip the preview and make the selected polygons light green
            if (bufferSize === 0) {
                highlightedPolygons.forEach(layer => {
                    // Change the color of the selected polygons to light green
                    layer.setStyle({
                        color: 'green',
                        weight: 3
                    });
                });
                // Remove the preview layer if it exists
                if (previewLayer) {
                    map.removeLayer(previewLayer);
                    previewLayer = null;
                }
                return; // Exit function without creating the preview
            }
            try {
                // Buffer each selected polygon using the buffer size (in meters)
                const bufferedPolygons = highlightedPolygons.map(layer => {
                    const geoJson = layer.toGeoJSON(); // Convert Leaflet layer to GeoJSON
                    return turf.buffer(geoJson, bufferSize, {
                        units: 'meters'
                    });
                });
                // Combine all buffered polygons using Turf.js union
                const combinedPolygon = bufferedPolygons.reduce((combined, feature, index) => {
                    if (index === 0) return feature; // Use the first polygon as the base
                    return turf.union(combined, feature);
                });
                // If a preview already exists, remove it before adding a new one
                if (previewLayer) {
                    map.removeLayer(previewLayer);
                }
                // Add the preview layer (combined polygon) to the map
                previewLayer = L.geoJSON(combinedPolygon, {
                    style: {
                        color: 'green',
                        weight: 3,
                        fillOpacity: 0.3
                    },
                    interactive: false // Disable interaction with the preview layer
                }).addTo(map);
                // Change the color of the selected polygons to light green
                highlightedPolygons.forEach(layer => {
                    layer.setStyle({
                        color: 'green',
                        weight: 3
                    });
                });
                console.log('Preview Combined Polygon:', combinedPolygon);
            } catch (err) {
                console.error('Error previewing combined polygon:', err);
                alert('Error previewing polygon. Please ensure the selected polygons are valid.');
            }
        }

        function clearAllSelections() {
            // Clear highlighted polygons
            highlightedPolygons.forEach(layer => {
                layer.setStyle({
                    color: 'blue',
                    weight: 2
                }); // Reset style to blue
            });
            highlightedPolygons.length = 0; // Clear the array
            
            // Remove all layers from map
            if (previewLayer) {
                map.removeLayer(previewLayer);
                previewLayer = null;
            }
            if (geoJsonLayer) {
                map.removeLayer(geoJsonLayer);
                geoJsonLayer = null;
            }
            if (currentRoutePolyline) {
                map.removeLayer(currentRoutePolyline);
                currentRoutePolyline = null;
            }
            if (currentPositionMarker) {
                map.removeLayer(currentPositionMarker);
                currentPositionMarker = null;
            }
            if (routePolyline) {
                map.removeLayer(routePolyline);
                routePolyline = null;
            }
            
            // Reset all variables to initial state
            gpxData = null;
            routePoints = [];
            routeIndex = 0;
            animationInProgress = false;
            animationPaused = false;
            currentAnimationTime = 0;
            totalRouteDistance = 0;
            currentRouteDistance = 0;
            currentInterpolatedPosition = null;
            interpolationStep = 0;
            
            // Clear animation interval if running
            if (animationInterval) {
                clearTimeout(animationInterval);
                animationInterval = null;
            }
            
            // Reset UI elements
            document.getElementById('routeLength').innerHTML = '';
            document.getElementById('searchBox').value = '';
            document.getElementById('bufferSize').value = '1';
            document.getElementById('searchRules').selectedIndex = 0; // Reset to first option
            
            // Stop animation and hide media controls
            stopAnimation();
        }
        // Function to search for a location using Nominatim
        function searchLocation() {
            const searchButton = document.getElementById('searchButton');
            const searchQuery = document.getElementById('searchBox').value;
            if (!searchQuery) {
                alert('Please enter a location to search.');
                return;
            }
            // Add loading spinner
            searchButton.classList.add('button-loading');
            searchButton.innerHTML = 'Searching <span class="spinner"></span>';
            const url = `https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(searchQuery)}&format=json&limit=1`;
            fetch(url).then(response => response.json()).then(data => {
                if (data.length === 0) {
                    alert('No results found. Please try a different search term.');
                    return;
                }
                const {
                    lat,
                    lon,
                    display_name
                } = data[0];
                map.setView([parseFloat(lat), parseFloat(lon)], 14); // Center map on the search result
                saveMapStateToHash(); // Update hash fragment with new position
                console.log('Search result:', display_name);
            }).catch(err => console.error('Error searching location:', err)).finally(() => {
                // Remove loading spinner
                searchButton.classList.remove('button-loading');
                searchButton.innerHTML = 'Search';
            });
        }
        let gpxData = null; // Variable to store GPX data after route generation
        function previewGPXRoute() {
            const previewGPXButton = document.getElementById('previewGPXButton');
            previewGPXButton.classList.add('button-loading');
            previewGPXButton.innerHTML = 'Generating Route <span class="spinner"></span>';
            if (highlightedPolygons.length === 0) {
                alert('No area has been selected.');
                stopSpinner(previewGPXButton, 'Generate Route');
                return;
            }
            const bufferSize = parseInt(document.getElementById('bufferSize').value, 10);
            try {
                const bufferedPolygons = highlightedPolygons.map(layer => {
                    const geoJson = layer.toGeoJSON();
                    return turf.buffer(geoJson, bufferSize, {
                        units: 'meters'
                    });
                });
                const combinedPolygon = bufferedPolygons.reduce((combined, feature, index) => {
                    if (index === 0) return feature;
                    return turf.union(combined, feature);
                });
                if (combinedPolygon.geometry.type === 'MultiPolygon') {
                    alert('Error: One or more selected areas are too far apart. You can increase the buffer to merge adjacent areas.');
                    stopSpinner(previewGPXButton, 'Generate Route');
                    return;
                }
                
                // Calculate the area of the combined polygon
                const areaInSquareMeters = turf.area(combinedPolygon);
                const areaInSquareKm = areaInSquareMeters / 1000000; // Convert to km²
                const areaInSquareMi = areaInSquareMeters / 2589988.11; // Convert to sq mi
                
                // Check if area is very large (5 km² threshold)
                if (areaInSquareKm > 5) {
                    const confirmMessage = `Area is very big and may not successfully generate (${areaInSquareKm.toFixed(2)}km²/${areaInSquareMi.toFixed(2)}sq mi). Continue?`;
                    if (!confirm(confirmMessage)) {
                        stopSpinner(previewGPXButton, 'Generate Route');
                        return;
                    }
                }
                
                const combinedCoords = combinedPolygon.geometry.coordinates;
                fetch('/generate-gpx/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        polygon_coords: combinedCoords[0]
                    })
                }).then(response => response.json()).then(data => {
                    if (data.gpx) {
                        gpxData = data.gpx;
                        const parser = new DOMParser();
                        const xmlDoc = parser.parseFromString(data.gpx, 'application/xml');
                        const trackpoints = xmlDoc.getElementsByTagName('trkpt');
                        routePoints = Array.from(trackpoints).map(pt => {
                            const lat = parseFloat(pt.getAttribute('lat'));
                            const lon = parseFloat(pt.getAttribute('lon'));
                            return [lat, lon];
                        });
                        // Calculate the total distance using Turf.js
                        const line = turf.lineString(routePoints.map(([lat, lon]) => [lon, lat])); // Convert to GeoJSON format
                        const distanceKm = turf.length(line, {
                            units: 'kilometers'
                        });
                        const distanceMi = turf.length(line, {
                            units: 'miles'
                        });
                        
                        // Extract street length, efficiency, and coverage from GPX description
                        const descElement = xmlDoc.getElementsByTagName('desc')[0];
                        let streetLengthKm = 0;
                        let streetLengthMi = 0;
                        let efficiencyDisplay = "0%";
                        let coverageDisplay = "0%";
                        
                        if (descElement && descElement.textContent) {
                            const desc = descElement.textContent;
                            const streetMatch = desc.match(/Street Length: ([\d.]+) km \(([\d.]+) mi\)/);
                            const efficiencyMatch = desc.match(/Efficiency: ([\d.]+%)/);
                            const coverageMatch = desc.match(/Coverage: ([\d.]+%)/);
                            
                            if (streetMatch) {
                                streetLengthKm = parseFloat(streetMatch[1]);
                                streetLengthMi = parseFloat(streetMatch[2]);
                            }
                            if (efficiencyMatch) {
                                efficiencyDisplay = efficiencyMatch[1];
                            }
                            if (coverageMatch) {
                                coverageDisplay = coverageMatch[1];
                            }
                        }
                        
                        // Calculate the area for display in route statistics
                        let areaStats = '';
                        try {
                            const areaInSquareMeters = turf.area(combinedPolygon);
                            const areaInSquareKm = areaInSquareMeters / 1000000;
                            const areaInSquareMi = areaInSquareMeters / 2589988.11;
                            const areaWarning = areaInSquareKm > 5 ? ' <span style="color: red; font-weight: bold;">⚠️ Large Area</span>' : '';
                            areaStats = `<strong>Selected Area:</strong> ${areaInSquareKm.toFixed(2)} km² (${areaInSquareMi.toFixed(2)} sq mi)${areaWarning}<br>`;
                        } catch (err) {
                            console.error('Error calculating area for route stats:', err);
                        }
                        
                        // Update the routeLength paragraph with all metrics including area
                        document.getElementById('routeLength').innerHTML = `
                            ${areaStats}
                            <strong>Route Length:</strong> ${distanceKm.toFixed(2)} km (${distanceMi.toFixed(2)} mi)<br>
                            <strong>Street Length:</strong> ${streetLengthKm.toFixed(2)} km (${streetLengthMi.toFixed(2)} mi)<br>
                            <strong>Efficiency:</strong> ${efficiencyDisplay} (Street÷Route)<br>
                            <strong>Coverage:</strong> ${coverageDisplay} (Route÷Street)
                        `;
                        if (previewLayer) {
                            map.removeLayer(previewLayer);
                        }
                        previewLayer = L.polyline(routePoints, {
                            color: 'red',
                            weight: 4,
                            opacity: 0.7
                        }).addTo(map);
                        map.fitBounds(previewLayer.getBounds());
                    } else {
                        alert('Error generating GPX: ' + data.error);
                    }
                }).catch(err => {
                    console.error('Error:', err);
                    alert('Error generating GPX.');
                }).finally(() => {
                    stopSpinner(previewGPXButton, 'Generate Route');
                });
            } catch (err) {
                console.error('Error combining polygons:', err);
                alert('Error combining polygons.');
                stopSpinner(previewGPXButton, 'Generate Route');
            }
        }

        function combineAndDownloadGPX() {
            if (!gpxData) {
                alert('No GPX data available. Please generate the route first.');
                return;
            }
            const blob = new Blob([gpxData], {
                type: 'application/gpx+xml'
            });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'route.gpx';
            link.click();
        }

        function stopSpinner(button, defaultText) {
            button.classList.remove('button-loading');
            button.innerHTML = defaultText;
        }
        let routePolyline = null; // To hold the polyline layer
        let routeIndex = 0; // To track the current point in the route animation
        let routePoints = []; // To store the GPX points
        let currentRoutePolyline = null; // To hold the red polyline for the route
        let currentPositionMarker = null; // To hold the current position circle marker
        let animationInProgress = false; // Track if animation is in progress
        let animationPaused = false; // Track if animation is paused
        let animationSpeed = 1; // Animation speed multiplier
        let animationInterval = null; // Store the animation interval
        let totalAnimationTime = 0; // Total time for the animation
        let currentAnimationTime = 0; // Current time in the animation
        let totalRouteDistance = 0; // Total distance of the route in km
        let currentRouteDistance = 0; // Current distance covered in km
        
        // Interpolation variables for smoother movement
        let currentInterpolatedPosition = null; // Current interpolated position between points
        let interpolationStep = 0; // Current interpolation step (0-1)
        let interpolationSteps = 10; // Number of interpolation steps between points
        let useInterpolation = false; // Whether to use interpolation (for slower speeds)
        // Function to interpolate between two points
        function interpolatePoint(point1, point2, t) {
            return [
                point1[0] + (point2[0] - point1[0]) * t,
                point1[1] + (point2[1] - point1[1]) * t
            ];
        }
        
        // Function to determine if interpolation should be used based on speed
        function shouldUseInterpolation(speed) {
            return speed < 1; // Use interpolation for speeds slower than 1x
        }
        
        // Function to show/hide media controls
        function toggleMediaControls(show) {
            const mediaControls = document.getElementById('mediaControls');
            const bottomControls = document.querySelector('.leaflet-bottom');
            
            if (show) {
                mediaControls.classList.add('visible');
                // Hide leaflet-bottom on mobile when media controls are visible
                if (window.innerWidth <= 600 || (window.innerHeight <= 450 && window.innerWidth > window.innerHeight)) {
                    if (bottomControls) {
                        bottomControls.style.display = 'none';
                    }
                }
            } else {
                mediaControls.classList.remove('visible');
                // Show leaflet-bottom again when media controls are hidden
                if (bottomControls) {
                    bottomControls.style.display = '';
                }
            }
        }

        // Function to calculate distance between two points
        function calculateDistance(point1, point2) {
            const R = 6371; // Earth's radius in kilometers
            const dLat = (point2[0] - point1[0]) * Math.PI / 180;
            const dLon = (point2[1] - point1[1]) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                    Math.cos(point1[0] * Math.PI / 180) * Math.cos(point2[0] * Math.PI / 180) *
                    Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        // Function to calculate total distance up to a point
        function calculateDistanceToPoint(points, endIndex) {
            let distance = 0;
            for (let i = 1; i <= endIndex && i < points.length; i++) {
                distance += calculateDistance(points[i-1], points[i]);
            }
            return distance;
        }

        // Function to update progress bar
        function updateProgress() {
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');
            
            if (routePoints.length === 0) return;
            
            const progress = (routeIndex / routePoints.length) * 100;
            progressFill.style.width = progress + '%';
            
            // Calculate current distance
            currentRouteDistance = calculateDistanceToPoint(routePoints, routeIndex);
            
            // Update distance display
            progressText.textContent = `${currentRouteDistance.toFixed(1)} km / ${totalRouteDistance.toFixed(1)} km`;
        }

        // Function to format time for display
        function formatTime(milliseconds) {
            const seconds = Math.floor(milliseconds / 1000);
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // Function to animate the route
        function playRouteAnimation() {
            if (routePoints.length === 0) {
                alert('No route to animate. Please generate the route first.');
                return;
            }
            
            // If animation is paused, resume it
            if (animationPaused) {
                resumeAnimation();
                return;
            }
            
            // If animation is already in progress or finished, stop and reset it
            if (animationInProgress || routeIndex >= routePoints.length) {
                stopAnimation();
                return;
            }
            
            // Start the animation
            startAnimation();
        }

        // Function to start animation
        function startAnimation() {
            animationInProgress = true;
            animationPaused = false;
            currentAnimationTime = 0;
            
            // Initialize interpolation
            useInterpolation = shouldUseInterpolation(animationSpeed);
            interpolationStep = 0;
            currentInterpolatedPosition = null;
            
            // Adjust interpolation steps based on speed for optimal smoothness
            if (animationSpeed <= 0.25) {
                interpolationSteps = 20; // More steps for very slow speeds
            } else if (animationSpeed <= 0.5) {
                interpolationSteps = 15; // Medium steps for slow speeds
            } else {
                interpolationSteps = 10; // Default steps for other speeds
            }
            
            // Calculate total animation time (30ms per point)
            totalAnimationTime = routePoints.length * 30;
            
            // Calculate total route distance
            totalRouteDistance = calculateDistanceToPoint(routePoints, routePoints.length - 1);
            
            // Show media controls
            toggleMediaControls(true);
            
            // Update play/pause button
            const playPauseBtn = document.getElementById('playPauseBtn');
            playPauseBtn.textContent = '⏸️';
            playPauseBtn.classList.add('active');
            
            // Remove the existing preview line before starting the animation
            if (previewLayer) {
                map.removeLayer(previewLayer);
                previewLayer = null;
            }
            
            // Start the animation loop
            continueAnimation();
        }

        // Function to pause animation
        function pauseAnimation() {
            animationPaused = true;
            if (animationInterval) {
                clearTimeout(animationInterval);
                animationInterval = null;
            }
            
            // Update play/pause button
            const playPauseBtn = document.getElementById('playPauseBtn');
            playPauseBtn.textContent = '▶️';
            playPauseBtn.classList.remove('active');
        }

        // Function to resume animation
        function resumeAnimation() {
            animationPaused = false;
            
            // Update play/pause button
            const playPauseBtn = document.getElementById('playPauseBtn');
            playPauseBtn.textContent = '⏸️';
            playPauseBtn.classList.add('active');
            
            // Continue the animation
            continueAnimation();
        }

        // Function to stop animation
        function stopAnimation() {
            animationInProgress = false;
            animationPaused = false;
            routeIndex = 0;
            currentAnimationTime = 0;
            currentRouteDistance = 0;
            
            if (animationInterval) {
                clearTimeout(animationInterval);
                animationInterval = null;
            }
            
            // Remove polylines and marker
            if (currentRoutePolyline) {
                map.removeLayer(currentRoutePolyline);
                currentRoutePolyline = null;
            }
            if (currentPositionMarker) {
                map.removeLayer(currentPositionMarker);
                currentPositionMarker = null;
            }
            
            // Show the full route again
            if (routePoints.length > 0) {
                previewLayer = L.polyline(routePoints, {
                    color: 'red',
                    weight: 4,
                    opacity: 0.7
                }).addTo(map);
            }
            
            // Hide media controls
            toggleMediaControls(false);
            
            // Reset buttons
            const playPauseBtn = document.getElementById('playPauseBtn');
            playPauseBtn.textContent = '▶️';
            playPauseBtn.classList.remove('active');
            
            // Reset progress
            updateProgress();
        }

        // Function to play from the beginning
        function playFromBeginning() {
            if (routePoints.length === 0) {
                alert('No route to animate. Please generate the route first.');
                return;
            }
            
            // Stop current animation
            if (animationInProgress) {
                if (animationInterval) {
                    clearTimeout(animationInterval);
                    animationInterval = null;
                }
            }
            
            // Reset to beginning
            routeIndex = 0;
            currentAnimationTime = 0;
            animationPaused = false;
            
            // Start animation
            startAnimation();
        }

        // Function to continue the animation
        function continueAnimation() {
            if (!animationInProgress || animationPaused || routeIndex >= routePoints.length) {
                if (routeIndex >= routePoints.length) {
                    // Animation completed
                    animationInProgress = false;
                    const playPauseBtn = document.getElementById('playPauseBtn');
                    playPauseBtn.textContent = '▶️';
                    playPauseBtn.classList.remove('active');
                }
                return;
            }
            
            let currentPoint;
            
            if (useInterpolation && routeIndex < routePoints.length - 1) {
                // Use interpolation for smoother movement
                const point1 = routePoints[routeIndex];
                const point2 = routePoints[routeIndex + 1];
                const t = interpolationStep / interpolationSteps;
                
                currentPoint = interpolatePoint(point1, point2, t);
                currentInterpolatedPosition = currentPoint;
                
                // Increment interpolation step
                interpolationStep++;
                
                // If we've completed interpolation between these two points, move to next point
                if (interpolationStep >= interpolationSteps) {
                    interpolationStep = 0;
                    routeIndex++;
                }
            } else {
                // Use discrete point movement (original behavior)
                currentPoint = routePoints[routeIndex];
                routeIndex++;
            }
            
            // Create interpolated route lines
            let routeUntilCurrent;
            
            if (useInterpolation && currentInterpolatedPosition) {
                // Create interpolated route up to current position
                routeUntilCurrent = routePoints.slice(0, routeIndex + 1);
                if (currentInterpolatedPosition) {
                    routeUntilCurrent.push(currentInterpolatedPosition);
                }
            } else {
                // Use discrete points (original behavior)
                routeUntilCurrent = routePoints.slice(0, routeIndex + 1);
            }
            
            // Remove the old red polyline if it exists
            if (currentRoutePolyline) {
                map.removeLayer(currentRoutePolyline);
            }
            
            // Create a new red polyline for the current route
            currentRoutePolyline = L.polyline(routeUntilCurrent, {
                color: 'red',
                weight: 4,
                opacity: 0.7
            }).addTo(map);
            
            // Add/update current position marker
            if (currentPositionMarker) {
                map.removeLayer(currentPositionMarker);
            }
            
            currentPositionMarker = L.circleMarker(currentPoint, {
                radius: 8,
                fillColor: '#ff6b35',
                color: '#ffffff',
                weight: 3,
                opacity: 1,
                fillOpacity: 0.8
            }).addTo(map);
            
            // Update animation time
            if (!useInterpolation) {
                currentAnimationTime += 30;
            } else {
                // For interpolation, update time more frequently for smoother progress
                currentAnimationTime += 30 / interpolationSteps;
            }
            
            // Update progress
            updateProgress();
            
            // Calculate next interval based on speed
            let interval;
            if (useInterpolation) {
                // For interpolation, use smaller intervals for smoother movement
                interval = Math.max(30 / (animationSpeed * interpolationSteps), 2); // Minimum 2ms interval
            } else {
                interval = Math.max(30 / animationSpeed, 5); // Minimum 5ms interval
            }
            
            // Schedule next animation step
            animationInterval = setTimeout(continueAnimation, interval);
        }
        // Event listeners for the buttons
        document.getElementById('downloadButton').addEventListener('click', combineAndDownloadGPX);
        document.getElementById('clearButton').addEventListener('click', function () {
            clearAllSelections();
        });
        // Event listener for the search button
        document.getElementById('searchButton').addEventListener('click', searchLocation);
        // Event listener for the Fetch button
        document.getElementById('fetchButton').addEventListener('click', fetchDataByRule);
        // Event listener for the buffer size input to automatically trigger preview update
        document.getElementById('bufferSize').addEventListener('input', (event) => {
            const bufferSize = event.target.value;
            // Automatically trigger the preview when buffer size changes
            previewCombinedPolygon();
        });
        document.getElementById('bufferSize').addEventListener('wheel', function (event) {
            // Prevent the page from scrolling when using the scroll wheel on the input field
            event.preventDefault();
            let currentValue = parseInt(this.value, 10);
            if (isNaN(currentValue)) currentValue = 1; // If the value is NaN (e.g., empty), default to 1
            const step = 1; // The amount to change when scrolling (in meters)
            if (event.deltaY < 0) {
                // Scroll up (increase the value)
                this.value = Math.min(currentValue + step, 100); // Cap at 100
            } else if (event.deltaY > 0) {
                // Scroll down (decrease the value)
                this.value = Math.max(currentValue - step, 1); // Cap at 1
            }
            // Trigger the input event to automatically update the preview when the value changes
            previewCombinedPolygon();
        });
        document.getElementById('searchBox').addEventListener('keydown', function (event) {
            // Check if the pressed key is Enter (key code 13)
            if (event.key === 'Enter') {
                searchLocation(); // Trigger the searchLocation function
            }
        });
        // Event listener for the Preview GPX button
        document.getElementById('previewGPXButton').addEventListener('click', previewGPXRoute);
        // Add event listener for the Play Route button
        document.getElementById("playRouteButton").addEventListener("click", playRouteAnimation);

        // Media controls event listeners
        document.getElementById('playPauseBtn').addEventListener('click', function() {
            if (animationInProgress && !animationPaused) {
                pauseAnimation();
            } else if (animationPaused) {
                resumeAnimation();
            } else {
                playRouteAnimation();
            }
        });

        document.getElementById('playFromBeginningBtn').addEventListener('click', function() {
            playFromBeginning();
        });

        document.getElementById('closeBtn').addEventListener('click', function() {
            stopAnimation();
        });

        // Speed control event listeners
        document.querySelectorAll('.speed-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                // Remove active class from all speed buttons
                document.querySelectorAll('.speed-btn').forEach(b => b.classList.remove('active'));
                // Add active class to clicked button
                this.classList.add('active');
                // Update animation speed
                animationSpeed = parseFloat(this.getAttribute('data-speed'));
                
                // Update interpolation settings if animation is in progress
                if (animationInProgress) {
                    useInterpolation = shouldUseInterpolation(animationSpeed);
                    // Adjust interpolation steps based on speed for optimal smoothness
                    if (animationSpeed <= 0.25) {
                        interpolationSteps = 20; // More steps for very slow speeds
                    } else if (animationSpeed <= 0.5) {
                        interpolationSteps = 15; // Medium steps for slow speeds
                    } else {
                        interpolationSteps = 10; // Default steps for other speeds
                    }
                }
            });
        });

        // Progress bar drag functionality
        const progressBar = document.getElementById('progressBar');
        let isDragging = false;

        function seekToPosition(clientX) {
            if (routePoints.length === 0) return;
            
            const rect = progressBar.getBoundingClientRect();
            const clickX = clientX - rect.left;
            const percentage = Math.max(0, Math.min(1, clickX / rect.width));
            const newIndex = Math.floor(percentage * routePoints.length);
            
            if (newIndex >= 0 && newIndex < routePoints.length) {
                routeIndex = newIndex;
                currentAnimationTime = newIndex * 30;
                currentRouteDistance = calculateDistanceToPoint(routePoints, routeIndex);
                updateProgress();
                
                // Update the route display
                if (routeIndex > 0) {
                    const routeUntilCurrent = routePoints.slice(0, routeIndex + 1);
                    
                    // Remove existing polylines
                    if (currentRoutePolyline) {
                        map.removeLayer(currentRoutePolyline);
                    }
                    
                    // Create new polylines
                    
                    currentRoutePolyline = L.polyline(routeUntilCurrent, {
                        color: 'red',
                        weight: 4,
                        opacity: 0.7
                    }).addTo(map);
                    
                    // Add/update current position marker
                    if (currentPositionMarker) {
                        map.removeLayer(currentPositionMarker);
                    }
                    
                    const currentPoint = routePoints[routeIndex];
                    currentPositionMarker = L.circleMarker(currentPoint, {
                        radius: 8,
                        fillColor: '#ff6b35',
                        color: '#ffffff',
                        weight: 3,
                        opacity: 1,
                        fillOpacity: 0.8
                    }).addTo(map);
                }
            }
        }

        progressBar.addEventListener('mousedown', function(e) {
            isDragging = true;
            progressBar.classList.add('dragging');
            seekToPosition(e.clientX);
            e.preventDefault();
        });

        progressBar.addEventListener('mousemove', function(e) {
            if (isDragging) {
                seekToPosition(e.clientX);
            }
        });

        // Use document-level events to handle dragging outside the progress bar
        document.addEventListener('mousemove', function(e) {
            if (isDragging) {
                seekToPosition(e.clientX);
            }
        });

        document.addEventListener('mouseup', function(e) {
            if (isDragging) {
                isDragging = false;
                progressBar.classList.remove('dragging');
            }
        });

        // Touch events for mobile
        progressBar.addEventListener('touchstart', function(e) {
            isDragging = true;
            progressBar.classList.add('dragging');
            seekToPosition(e.touches[0].clientX);
            e.preventDefault();
        });

        // Use document-level touch events to handle dragging outside the progress bar
        document.addEventListener('touchmove', function(e) {
            if (isDragging) {
                seekToPosition(e.touches[0].clientX);
                e.preventDefault();
            }
        });

        document.addEventListener('touchend', function(e) {
            if (isDragging) {
                isDragging = false;
                progressBar.classList.remove('dragging');
            }
        });

        const bufferInput = document.getElementById('bufferSize');

        // Disable zooming when mouse hovers over the buffer input
        bufferInput.addEventListener('mouseover', () => {
            map.scrollWheelZoom.disable();
        });

        // Enable zooming again when mouse leaves the buffer input
        bufferInput.addEventListener('mouseout', () => {
            map.scrollWheelZoom.enable();
        });


        // --- Integration of combined.html features ---

        // Global variables for Mapillary, Panoramax, and Kartaview
        var accessToken = 'MLY|31706646702259607|13ea77823b67451ce0704c521dcbf67f';
        var mapillaryLayer, panoramaxLayer, kartaviewLayer, mapilioLayer;

        // Helper function to parse Panoramax date
        function parsePanoramaxDate(dateStr) {
            if (!dateStr) return null;
            var parts = dateStr.split('-');
            if (parts.length !== 3) return null;
            return new Date(parts[0], parts[1] - 1, parts[2]);
        }

        // Helper function to check Mapillary filters
        function passesMapillaryFilters(properties, filters, layerName) {
            if (filters.startDate || filters.endDate) {
                const capturedAt = properties.captured_at;
                if (!capturedAt) return false;
                const capturedDate = new Date(capturedAt);
                if (filters.startDate && capturedDate < filters.startDate) return false;
                if (filters.endDate && capturedDate > filters.endDate) return false;
            }
            if (filters.imageType === '360' && properties.is_pano !== true) {
                return false;
            }
            if (filters.imageType === 'classic' && properties.is_pano === true) {
                return false;
            }
            if (filters.mapillaryUserId && properties.creator_id !== filters.mapillaryUserId) {
                return false;
            }
            return true;
        }

        // Helper function to check Panoramax filters
        function passesPanoramaxFilters(properties, filters, layerName) {
            if (layerName === 'sequences') {
                if (filters.startDate || filters.endDate) {
                    var dateStr = properties.date;
                    var captureDate = parsePanoramaxDate(dateStr);
                    if (!captureDate) return false;
                    if (filters.startDate && captureDate < filters.startDate) return false;
                    if (filters.endDate && captureDate > filters.endDate) return false;
                }
                if (filters.imageType === '360' && properties.type !== 'equirectangular') {
                    return false;
                }
                if (filters.imageType === 'classic' && properties.type === 'equirectangular') {
                    return false;
                }
                if (filters.panoramaxUsername && properties.account_id !== filters.panoramaxUsername) {
                    return false;
                }
            }
            return true;
        }

        // Function to create Mapillary layer with filters
        function createMapillaryLayer(filters = {}) {
            if (mapillaryLayer) map.removeLayer(mapillaryLayer);
            mapillaryLayer = L.vectorGrid.protobuf(
                `https://tiles.mapillary.com/maps/vtp/mly1_public/2/{z}/{x}/{y}?access_token=${accessToken}`,
                {
                    vectorTileLayerStyles: {
                        overview: function (properties, zoom) {
                            if (!passesMapillaryFilters(properties, filters, 'overview')) {
                                return { fillOpacity: 0, opacity: 0 };
                            }
                            return {
                                radius: 0.001,
                                weight: 0,
                                color: '#05cb63',
                                fill: true,
                                fillColor: '#05cb63',
                                fillOpacity: 1
                            };
                        },
                        sequence: function (properties, zoom) {
                            if (!passesMapillaryFilters(properties, filters, 'sequence')) {
                                return { opacity: 0 };
                            }
                            return {
                                weight: 0.5,
                                color: '#05cb63',
                                opacity: 0.9
                            };
                        },
                        image: function (properties, zoom) {
                            if (!passesMapillaryFilters(properties, filters, 'image')) {
                                return { fillOpacity: 0, opacity: 0 };
                            }
                            return {
                                radius: 0,
                                weight: 0,
                                color: '#05cb63',
                                fill: false,
                                fillColor: '#05cb63',
                                fillOpacity: 0.5
                            };
                        }
                    },
                    maxNativeZoom: 13,
                    maxZoom: 19,
                    minZoom: 13,
                    attribution: '<a href="https://www.mapillary.com">Mapillary</a>'
                }
            );
        }

        // Function to create Panoramax layer with filters
        function createPanoramaxLayer(filters = {}) {
            if (panoramaxLayer) map.removeLayer(panoramaxLayer);
            panoramaxLayer = L.vectorGrid.protobuf(
                'https://api.panoramax.xyz/api/map/{z}/{x}/{y}.mvt', {
                maxNativeZoom: 13,
                maxZoom: 19,
                minZoom: 13,
                vectorTileLayerStyles: {
                    grid: {
                        weight: 0,
                        color: '#555555',
                        fillOpacity: 0,
                        opacity: 0.5
                    },
                    sequences: function (properties, zoom) {
                        if (zoom < 7) return { opacity: 0 };
                        if (!passesPanoramaxFilters(properties, filters, 'sequences')) {
                            return { opacity: 0 };
                        }
                        return {
                            weight: 0.5,
                            color: '#854900',
                            opacity: 0.9
                        };
                    },
                    pictures: {
                        radius: 3,
                        fill: true,
                        fillColor: '#550dff',
                        fillOpacity: 0.9,
                        stroke: false
                    }
                },
                attribution: '<a href="https://panoramax.fr">Panoramax</a>'
            }
            );
        }

        // Kartaview Layer initialization
        kartaviewLayer = L.tileLayer('https://api.openstreetcam.org/2.0/sequence/tiles/{x}/{y}/{z}.png', {
			maxNativeZoom: 14,
            maxZoom: 19,
            minZoom: 13,
            attribution: '<a href="https://kartaview.org">KartaView</a>'
        });
		
		function passesMapilioFilters(properties, filters) {
			// Filter by image type
			if (filters.imageType === '360' && properties.fov < 360) {
				return false;
			}
			if (filters.imageType === 'classic' && properties.fov >= 360) {
				return false;
			}

			// Filter by capture date
			if (filters.startDate && properties.capture_time) {
				const capturedDate = new Date(properties.capture_time);
				if (capturedDate < filters.startDate) {
					return false;
				}
			}
			if (filters.endDate && properties.capture_time) {
				const capturedDate = new Date(properties.capture_time);
				if (capturedDate > filters.endDate) {
					return false;
				}
			}
			
			// Filter by Mapilio user ID (created_by_id)
			if (filters.mapilioUserId && properties.created_by_id) {
				if (properties.created_by_id !== filters.mapilioUserId) {
					return false;
				}
			}

			return true; // If no filters are failed, show the feature
		}

		/**
		 * Creates or re-creates the Mapilio vector tile layer with the specified filters.
		 * @param {object} filters - An object containing the filter criteria.
		 */
		function createMapilioLayer(filters = {}) {
			if (mapilioLayer) {
				map.removeLayer(mapilioLayer);
			}

			const mapilioUrl = 'https://geo.mapilio.com/map/{x}/{y}/{z}';

			mapilioLayer = L.vectorGrid.protobuf(mapilioUrl, {
				vectorTileLayerStyles: {
					// Style for the 'map_roads_line' layer you specified
					'map_roads_line': function(properties, zoom) {
						if (!passesMapilioFilters(properties, filters)) {
							return { weight: 0, opacity: 0 }; // Hide features that don't pass the filter
						}
						// Style for visible features
						return {
							weight: 1,
							color: '#8A2BE2', // Blue-violet color to distinguish from other layers
							opacity: 0.9
						};
					},
					'map_points': function(properties, zoom) {
						// Hide the layer by setting style to transparent and no weight
						return {
							weight: 0,
							opacity: 0,
							fillOpacity: 0
						};
					}
				},
				maxNativeZoom: 16,
				minZoom: 13, // The zoom level at which the layer becomes visible
				maxZoom: 19,
				rendererFactory: L.canvas.tile,
				attribution: '<a href="https://mapilio.com" target="_blank">Mapilio</a>'
			});
		}

        // Overlay Maps for Leaflet Layer Control
        var overlayMaps = {
            "Mapillary Coverage": null,
            "Panoramax Coverage": null,
            "KartaView Coverage*": kartaviewLayer,
			"Mapilio Coverage": null
        };
        var layerControl = null;

        // Function to update the Leaflet Layer Control
        function updateLayerControl() {
            if (layerControl) {
                layerControl.remove();
            }
            overlayMaps["Mapillary Coverage"] = mapillaryLayer;
            overlayMaps["Panoramax Coverage"] = panoramaxLayer;
            overlayMaps["KartaView Coverage*"] = kartaviewLayer;
			overlayMaps["Mapilio Coverage"] = mapilioLayer;
            layerControl = L.control.layers(baseMaps, overlayMaps).addTo(map);
        }

        // Update the UI tip visibility based on zoom for filter availability for Mapillary, Panoramax, and Mapilio
        function updateZoomTip() {
            var zoomLevel = map.getZoom();
            var tipElement = document.getElementById('zoomTip');
            tipElement.textContent = 'Zoom in to enable coverage layers. *Filtering is not available for KartaView.';
            if (zoomLevel < 13) {
                document.getElementById('applyFiltersBtn').disabled = true;
            } else {
                document.getElementById('applyFiltersBtn').disabled = false;
            }
        }

        // Function to apply filters to coverage layers
        function applyFilters() {
            var zoomLevel = map.getZoom();
            // Do filtering only if zoom is sufficient
            if (zoomLevel < 13) {
                alert('Zoom in to at least level 13 to apply filters on coverage layers. *Filtering is not available for KartaView.');
                return;
            }
            var mapillaryVisible = mapillaryLayer && map.hasLayer(mapillaryLayer);
            var panoramaxVisible = panoramaxLayer && map.hasLayer(panoramaxLayer);
			var mapilioVisible = mapilioLayer && map.hasLayer(mapilioLayer);
            var kartaviewVisible = kartaviewLayer && map.hasLayer(kartaviewLayer);

            var startDateStr = document.getElementById('startDate').value;
            var endDateStr = document.getElementById('endDate').value;
            var imageType = document.querySelector('.image-type-btn.active').getAttribute('data-type');
            var mapillaryUserIdStr = document.getElementById('mapillaryUserId').value.trim();
            var panoramaxUsernameStr = document.getElementById('panoramaxUsername').value.trim();
            var mapilioUserIdStr = document.getElementById('mapilioUserId').value.trim();

            var filters = {};
            if (startDateStr) filters.startDate = new Date(startDateStr);
            if (endDateStr) {
                filters.endDate = new Date(endDateStr);
                filters.endDate.setHours(23, 59, 59, 999);
            }
            if (imageType !== 'all') filters.imageType = imageType;
            if (mapillaryUserIdStr) filters.mapillaryUserId = parseInt(mapillaryUserIdStr, 10);
            if (panoramaxUsernameStr) filters.panoramaxUsername = panoramaxUsernameStr;
            if (mapilioUserIdStr) filters.mapilioUserId = parseInt(mapilioUserIdStr, 10);

            createMapillaryLayer(filters);
            createPanoramaxLayer(filters);
			createMapilioLayer(filters);

            if (mapillaryVisible) {
                mapillaryLayer.addTo(map);
            }
            if (panoramaxVisible) {
                panoramaxLayer.addTo(map);
            }
			if (mapilioVisible) {
				mapilioLayer.addTo(map);
			}
            if (kartaviewVisible) {
                // Kartaview is a standard tile layer, its filtering would require a separate approach
                // For now, it's just toggled
                kartaviewLayer.addTo(map);
            }
            updateLayerControl();
        }

        // Custom Filter Control
        var FilterControl = L.Control.extend({
            options: { position: 'topright' },
            onAdd: function (map) {
                var container = L.DomUtil.create('div', 'leaflet-control-filters');
                container.innerHTML = `
                    <div class="zoom-tip" id="zoomTip"></div>
                    <label>Start Date: <input type="date" id="startDate"></label>
                    <label>End Date: <input type="date" id="endDate"></label>
                    <label style="display: block; margin: 5px 0;">
                        <div style="display: block; margin-bottom: 3px;">Image Type:</div>
                        <div style="display: flex; gap: 2px; width: 100%; box-sizing: border-box;">
                            <button type="button" class="image-type-btn active" data-type="all">All</button>
                            <button type="button" class="image-type-btn" data-type="classic">Classic</button>
                            <button type="button" class="image-type-btn" data-type="360">360°</button>
                        </div>
                    </label>
                    <label><input type="text" id="mapillaryUserId" placeholder="Mapillary User ID"></label>
                    <label><input type="text" id="panoramaxUsername" placeholder="Panoramax Account ID"></label>
                    <label><input type="text" id="mapilioUserId" placeholder="Mapilio User ID"></label>
                    <button id="applyFiltersBtn">Apply Filters</button>
                `;
                L.DomEvent.disableClickPropagation(container);
                return container;
            }
        });
        // Toggle button control to hide/show filters
        var ToggleFilterControl = L.Control.extend({
            options: { position: 'topright' },
            onAdd: function (map) {
                var btn = L.DomUtil.create('button', '');
                btn.id = 'toggleFilterBtn';
                btn.textContent = 'Show Filter Menu';
                btn.style.background = '#fff';
                btn.style.padding = '6px';
                btn.style.border = 'none';
                btn.style.borderRadius = '5px';
                btn.style.boxShadow = '0 0 5px rgba(0,0,0,0.3)';
                btn.style.cursor = 'pointer';
				btn.style.color = 'black';
                 btn.onclick = function () {
                     var filterDiv = document.querySelector('.leaflet-control-filters');
                     var bottomControls = document.querySelector('.leaflet-bottom');
                     var isHidden = filterDiv.style.display === 'none' || 
                                   (filterDiv.style.display === '' && window.getComputedStyle(filterDiv).display === 'none');
                     if (isHidden) {
                         filterDiv.style.display = 'block';
                         btn.textContent = 'Hide Filter Menu';
                         // Hide bottom controls on mobile when filter menu is open
                         if (window.innerWidth <= 600 || (window.innerHeight <= 450 && window.innerWidth > window.innerHeight)) {
                             if (bottomControls) {
                                 bottomControls.classList.add('hidden-on-mobile');
                             }
                         }
                     } else {
                         filterDiv.style.display = 'none';
                         btn.textContent = 'Show Filter Menu';
                         // Show bottom controls again when filter menu is closed
                         if (bottomControls) {
                             bottomControls.classList.remove('hidden-on-mobile');
                         }
                     }
                 };
                L.DomEvent.disableClickPropagation(btn); // Prevent map interactions
                return btn;
            }
        });
        map.addControl(new ToggleFilterControl());

        var filterControl = new FilterControl();
        map.addControl(filterControl);

        // Initialize layers and controls
        createMapillaryLayer();
        createPanoramaxLayer();
		createMapilioLayer({});
        updateLayerControl();
        
        // Setup layers control mobile behavior
        function setupLayersControlMobileBehavior() {
            if (!layerControl || !layerControl._container) {
                return;
            }
            
            const bottomControls = document.querySelector('.leaflet-bottom');
            if (!bottomControls) {
                return;
            }
            
            // Function to check if we're on mobile
            function isMobile() {
                return window.innerWidth <= 600 || (window.innerHeight <= 450 && window.innerWidth > window.innerHeight);
            }
            
            // Function to toggle bottom controls visibility
            function toggleBottomControls(show) {
                if (!isMobile()) return;
                
                if (show) {
                    bottomControls.classList.remove('hidden-on-mobile');
                } else {
                    bottomControls.classList.add('hidden-on-mobile');
                }
            }
            
            // Use MutationObserver to watch for class changes on the layers control
            const observer = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                    if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                        const isExpanded = layerControl._container.classList.contains('leaflet-control-layers-expanded');
                        toggleBottomControls(!isExpanded);
                    }
                });
            });
            
            // Start observing
            observer.observe(layerControl._container, {
                attributes: true,
                attributeFilter: ['class']
            });
            
            // Also handle window resize
            window.addEventListener('resize', function() {
                if (!isMobile()) {
                    // If not mobile, ensure bottom controls are visible
                    bottomControls.classList.remove('hidden-on-mobile');
                }
            });
        }
        
        // Setup the behavior after a short delay to ensure the layers control is ready
        setTimeout(setupLayersControlMobileBehavior, 100);

        // Event listeners for filter controls
        map.whenReady(function () {
            var btn = document.getElementById('applyFiltersBtn');
            if (btn) btn.addEventListener('click', applyFilters); // Check if button exists before adding listener
            
            // Add event listeners for image type buttons
            var imageTypeButtons = document.querySelectorAll('.image-type-btn');
            imageTypeButtons.forEach(function(button) {
                button.addEventListener('click', function() {
                    // Remove active class from all buttons
                    imageTypeButtons.forEach(function(btn) {
                        btn.classList.remove('active');
                    });
                    // Add active class to clicked button
                    this.classList.add('active');
                });
            });
            
            // Initialize zoom tip and disable filters if zoom too low
            updateZoomTip();
            
            // Also setup layers control behavior here as a fallback
            setTimeout(setupLayersControlMobileBehavior, 200);
        });
        map.on('zoomend', updateZoomTip);
		
		map.attributionControl.setPrefix(`Route Crafter <a href="https://github.com/seen-one/Route-Crafter" target="_blank">GitHub</a> | ${map.attributionControl.options.prefix}`);
    </script>
</body>

</html>